var C=Object.defineProperty;var y=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var p=(e,n,a)=>n in e?C(e,n,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[n]=a,D=(e,n)=>{for(var a in n||(n={}))P.call(n,a)&&p(e,a,n[a]);if(y)for(var a of y(n))x.call(n,a)&&p(e,a,n[a]);return e};import{i as w,j as O,k as _,w as A,o as z,l as g,m as B,p as M}from"./entry-9ee8f5dc.mjs";const R=()=>null;function I(e,n,a={}){var o,d,h,m,v;if(typeof e!="string")throw new TypeError("asyncData key must be a string");if(typeof n!="function")throw new TypeError("asyncData handler must be a function");a=D({server:!0,default:R},a),a.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),a.lazy=(d=(o=a.lazy)!=null?o:a.defer)!=null?d:!1,a.initialCache=(h=a.initialCache)!=null?h:!0;const r=w(),i=M();if(i&&!i._nuxtOnBeforeMountCbs){const f=i._nuxtOnBeforeMountCbs=[];i&&(z(()=>{f.forEach(s=>{s()}),f.splice(0,f.length)}),g(()=>f.splice(0,f.length)))}const l=()=>a.initialCache&&r.payload.data[e]!==void 0,t={data:O((m=r.payload.data[e])!=null?m:a.default()),pending:_(!l()),error:_((v=r.payload._errors[e])!=null?v:null)};t.refresh=(f={})=>r._asyncDataPromises[e]?r._asyncDataPromises[e]:f._initial&&l()?r.payload.data[e]:(t.pending.value=!0,r._asyncDataPromises[e]=Promise.resolve(n(r)).then(s=>{a.transform&&(s=a.transform(s)),a.pick&&(s=j(s,a.pick)),t.data.value=s,t.error.value=null}).catch(s=>{t.error.value=s,t.data.value=B(a.default())}).finally(()=>{t.pending.value=!1,r.payload.data[e]=t.data.value,t.error.value&&(r.payload._errors[e]=!0),delete r._asyncDataPromises[e]}),r._asyncDataPromises[e]);const c=()=>t.refresh({_initial:!0}),b=a.server!==!1&&r.payload.serverRendered;{b&&r.isHydrating&&e in r.payload.data?t.pending.value=!1:i&&r.payload.serverRendered&&(r.isHydrating||a.lazy)?i._nuxtOnBeforeMountCbs.push(c):c(),a.watch&&A(a.watch,()=>t.refresh());const f=r.hook("app:data:refresh",s=>{if(!s||s.includes(e))return t.refresh()});i&&g(f)}const u=Promise.resolve(r._asyncDataPromises[e]).then(()=>t);return Object.assign(u,t),u}function N(e){const n=e?Array.isArray(e)?e:[e]:void 0;return w().callHook("app:data:refresh",n)}function j(e,n){const a={};for(const r of n)a[r]=e[r];return a}export{N as r,I as u};
